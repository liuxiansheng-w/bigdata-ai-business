# SQL优化归类总结 

## 一、索引优化 
1. 优先在WHERE及ORDER BY涉及的列上建立索引，避免全表扫描 。
2. 避免在WHERE子句中对字段进行NULL值判断 。
3. 避免使用!=/<>操作符（MySQL仅对<,<=,=,>,>=,BETWEEN,IN,部分LIKE使用索引） 。
4. 避免OR连接条件（改用UNION合并查询） 。
5. IN/NOT IN慎用（连续数值用BETWEEN替代） 。
6. LIKE查询避免%前缀（如`name like '%abc%'`全表扫描，`name like 'abc%'`可用索引） 。
7. 避免WHERE子句使用参数（可能导致全表扫描） 。
8. 避免对字段进行表达式/函数操作（如`substring(card_no,1,4)`） 。
9. 用EXISTS代替IN（减少全表扫描） 。
10. 索引数不超过6个（避免影响INSERT/UPDATE性能） 。
11. 避免更新clustered索引数据列（可能导致表记录顺序调整） 。

## 二、查询语句优化 
12. 优先使用数字型字段（减少存储开销和查询耗时） 。
13. 用varchar代替char（节省空间，提升查询效率） 。
14. 避免SELECT *（用具体字段列表代替） 。
15. 避免返回大数据量（需评估需求合理性） 。
16. 使用表别名（减少解析时间和列歧义） 。
17. 用临时表暂存中间结果（减少主表扫描，提升并发性能） 。
18. 部分查询加nolock（提升并发，可能读到脏数据） 。
19. 避免超过5表连接（用临时表/表变量替代） 。
20. 预计算结果存储（适用于SQL7.0前场景） 。
21. OR条件改UNION（匹配索引时用UNION ALL） 。

## 三、高级查询技巧 
22. IN列表按频率排序（高频在前减少判断次数） 。
23. 数据处理放服务器（如存储过程，减少网络开销） 。
24. 线程数配置（内存充足时=最大连接数+5；不足时启用线程池） 。
25. 查询关联顺序优化（明确A=B且B=固定值时，直接指定A/B=固定值） 。
26. 用EXISTS代替count(1)（判断记录存在） 。
27. 用>=代替>（可能利用索引） 。
28. 索引使用规范（聚簇索引优先、联合索引首字段必用、定期重建索引） 。
29. 避免列操作（如`substring`/`convert`，改写成索引友好形式） 。
30. 批量插入/更新（代替逐条操作） 。
 
## 四、性能监控与补充 
31. MySQL查询缓存（提升重复查询性能） 。
32. EXPLAIN分析（跟踪查询执行计划） 。
33. 单条结果加LIMIT 1（提前终止搜索） 。
34. 存储引擎选择（MyISAM读多写少，InnoDB事务及高并发） 。
35. 数据类型优化（更小字段、NOT NULL、ENUM类型） 
36. 字符串类型选择（char固定长度、varchar可变长度、text大文本） 。
37. 列操作移至等号右侧（避免表扫描） 。